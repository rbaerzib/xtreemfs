/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package org.xtreemfs.common.libxtreemfs.jni.generated;

public class FileHandleProxy {
  private long swigCPtr;
  protected boolean swigCMemOwn;

  protected FileHandleProxy(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(FileHandleProxy obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        xtreemfs_jniJNI.delete_FileHandleProxy(swigCPtr);
      }
      swigCPtr = 0;
    }
  }

  public int read(byte[] buf, int count, long offset) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
    return xtreemfs_jniJNI.FileHandleProxy_read__SWIG_0(swigCPtr, this, buf, count, offset);
  }

  public int write(byte[] buf, int count, long offset) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
    return xtreemfs_jniJNI.FileHandleProxy_write__SWIG_0(swigCPtr, this, buf, count, offset);
  }

  public void flush() throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
    xtreemfs_jniJNI.FileHandleProxy_flush(swigCPtr, this);
  }

  public void truncate(org.xtreemfs.foundation.pbrpc.generatedinterfaces.RPC.UserCredentials user_credentials, long new_file_size) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
    xtreemfs_jniJNI.FileHandleProxy_truncate(swigCPtr, this, user_credentials.toByteArray(), new_file_size);
  }

  public org.xtreemfs.pbrpc.generatedinterfaces.MRC.Stat getAttr(org.xtreemfs.foundation.pbrpc.generatedinterfaces.RPC.UserCredentials user_credentials) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
  byte[] buf = xtreemfs_jniJNI.FileHandleProxy_getAttr(swigCPtr, this, user_credentials.toByteArray());

  // It is possible that a serialized protobuf message has a length of 0, for 
  // example if it consists only of repeated fields of which none has an entry.
  // In that case it is preferred to parse the (empty) message and return it
  // instead of null. Null is only valid if the native call did return null.
  if (buf == null) {
    return null;
  }
  try {
    return org.xtreemfs.pbrpc.generatedinterfaces.MRC.Stat.parseFrom(buf);
  } catch (com.google.protobuf.InvalidProtocolBufferException e) {
    throw new RuntimeException(
        "Unable to parse org.xtreemfs.pbrpc.generatedinterfaces.MRC.Stat protocol message.");
  }
}

  public org.xtreemfs.pbrpc.generatedinterfaces.OSD.Lock acquireLock(int process_id, long offset, long length, boolean exclusive, boolean wait_for_lock) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
  byte[] buf = xtreemfs_jniJNI.FileHandleProxy_acquireLock(swigCPtr, this, process_id, offset, length, exclusive, wait_for_lock);

  // It is possible that a serialized protobuf message has a length of 0, for 
  // example if it consists only of repeated fields of which none has an entry.
  // In that case it is preferred to parse the (empty) message and return it
  // instead of null. Null is only valid if the native call did return null.
  if (buf == null) {
    return null;
  }

  try {
    return org.xtreemfs.pbrpc.generatedinterfaces.OSD.Lock.parseFrom(buf);
  } catch (com.google.protobuf.InvalidProtocolBufferException e) {
    throw new RuntimeException(
        "Unable to parse org.xtreemfs.pbrpc.generatedinterfaces.OSD.Lock protocol message.");
  }
}

  public org.xtreemfs.pbrpc.generatedinterfaces.OSD.Lock checkLock(int process_id, long offset, long length, boolean exclusive) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
  byte[] buf = xtreemfs_jniJNI.FileHandleProxy_checkLock(swigCPtr, this, process_id, offset, length, exclusive);

  // It is possible that a serialized protobuf message has a length of 0, for 
  // example if it consists only of repeated fields of which none has an entry.
  // In that case it is preferred to parse the (empty) message and return it
  // instead of null. Null is only valid if the native call did return null.
  if (buf == null) {
    return null;
  }

  try {
    return org.xtreemfs.pbrpc.generatedinterfaces.OSD.Lock.parseFrom(buf);
  } catch (com.google.protobuf.InvalidProtocolBufferException e) {
    throw new RuntimeException(
        "Unable to parse org.xtreemfs.pbrpc.generatedinterfaces.OSD.Lock protocol message.");
  }
}

  public void releaseLock(int process_id, long offset, long length, boolean exclusive) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
    xtreemfs_jniJNI.FileHandleProxy_releaseLock__SWIG_0(swigCPtr, this, process_id, offset, length, exclusive);
  }

  public void releaseLock(org.xtreemfs.pbrpc.generatedinterfaces.OSD.Lock lock) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
    xtreemfs_jniJNI.FileHandleProxy_releaseLock__SWIG_1(swigCPtr, this, lock.toByteArray());
  }

  public void releaseLockOfProcess(int process_id) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
    xtreemfs_jniJNI.FileHandleProxy_releaseLockOfProcess(swigCPtr, this, process_id);
  }

  public void pingReplica(String osd_uuid) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException, org.xtreemfs.common.libxtreemfs.exceptions.UUIDNotInXlocSetException {
    xtreemfs_jniJNI.FileHandleProxy_pingReplica(swigCPtr, this, osd_uuid);
  }

  public void close() throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException {
    xtreemfs_jniJNI.FileHandleProxy_close(swigCPtr, this);
  }

  public int readDirect(java.nio.ByteBuffer directBuffer, int count, long offset) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
 assert directBuffer.isDirect() : "Buffer must be allocated direct.";
    {
      return xtreemfs_jniJNI.FileHandleProxy_readDirect(swigCPtr, this, directBuffer, count, offset);
    }
  }

  public int writeDirect(java.nio.ByteBuffer directBuffer, int count, long offset) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
 assert directBuffer.isDirect() : "Buffer must be allocated direct.";
    {
      return xtreemfs_jniJNI.FileHandleProxy_writeDirect(swigCPtr, this, directBuffer, count, offset);
    }
  }

  public int read(byte[] buf, int buf_offset, int count, long offset) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
    return xtreemfs_jniJNI.FileHandleProxy_read__SWIG_1(swigCPtr, this, buf, buf_offset, count, offset);
  }

  public int write(byte[] buf, int buf_offset, int count, long offset) throws org.xtreemfs.common.libxtreemfs.exceptions.AddressToUUIDNotFoundException, java.io.IOException, org.xtreemfs.common.libxtreemfs.exceptions.PosixErrorException, org.xtreemfs.common.libxtreemfs.exceptions.XtreemFSException {
    return xtreemfs_jniJNI.FileHandleProxy_write__SWIG_1(swigCPtr, this, buf, buf_offset, count, offset);
  }

}
